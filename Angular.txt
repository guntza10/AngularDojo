Angular
-Angular มี app module ที่เป็น root module (main module) อย่างน้อย 1 module (module เป็น feature ต่างๆของ angular)
-แต่ละ module เป็น component กับ service
 -> component เป็นส่วนของ view
    -> angular app จะมี component อย่างน้อย 1 ตัว ที่เป็น root component(main component)
    -> ทุกๆ component จะอยู่ใน root component
    -> แต่ละ component จะมี html(view),class(control logic)
    -> มี service ที่จัดการกับ back end
-angular app จะมีได้หลาย module
 -> แต่ละ module จะมีได้หลาย component ,service
 -> module สามารถ import , export ได้


Package.json จะมีพวก library , module ที่ angular app ใช้
 -> จะ install เมื่อเรา run ng new (ตอนสร้าง Project) รวมถึง node_module

src folder
-main.ts เป็น entry point(จุดเริ่มต้น) ของ angular app
-app folder
 -> app.module.ts เป็น root module
 -> app.component.ts เป็น root component

เมื่อรัน ng serve 
-มันจะมาที่ main.ts จะมี bootstrap kick start ไปที่ app.module 
 -> ใน app module ก็จะมี bootstrap kick start ไปที่ app.component
    -> จะมี html,class
        -> class จะมี logic หรือ data สำหรับ view
-index.html เป็น main template (ที่มี app.component)
-เวลาจะใช้ component อื่น เอามาใช้ใน app.component(ที่เป็น root component ของ angular)

Component 
-Template(view) -> html
-Class(logic+data+method) -> typescript
-Metadata(information) -> ใช้บอกว่าเป็น particular class หรือ regular class ใน component
    -> จะมี decorator(function ที่จัดการข้อมูลเกี่ยวกับ class ของ component) ที่เป็น feature ที่ใช้ใน Typescript (ดูตัวอย่างใน app.component.ts)
    -> metadata templateUrl ที่อ้างอิงไฟล์ html สามารถใช้ property template ที่อ้างอิง tag html ได้โดยตรง (ดูตัวอย่างใน test.component.ts)
        -> ใช้ `` escape key ครอบ ถ้าจะทำเป็น multiple line
    -> metadata styleUrls สามารถใช้ styles แทนได้เหมือนข้างบน
-ทุกครั้งที่สร้าง component จะมีการการ Import component class ให้ auto ใน app.module
-ทุก component เอามาใช้ภายใต้ app.component(root component)
note : เวลาสร้าง component จะมี spec ไฟล์สำหรับ test(ไม่จำเป็นสามารถลบได้)
-เราสามารถ define selector ของ component ได้ 3 วิธี (ดูตัวอย่างที่ test.component.html)
    -> กำหนดชื่อ tag 
    -> กำหนดให้เป็น class css
    -> กำหนดให้เป็น attribute 

Interpolation => syntax{{}} (ดูตัวอย่างที่ binding.component.ts)
-คือการ binding data จาก component class สู่ component template(view)
-ไม่สามารถ define ตัวแปรได้ เช่น a = 2+2
-ไม่สามารถใช้ global javascript variable ได้ เช่น window ,screen 
note : interpolation มีข้อจำกัดที่สามารถใช้งานได้แค่กับ string value เท่านั้น ใช้กับ attribute ที่เป็น boolean ไม่ได้

Property Binding -> คือการ binding data ให้ attribute ที่เป็น boolean only? (ดูตัวอย่างที่ binding.component.ts)
-attribute ที่เป็น boolean 
    -> ไม่สามารถไปเปลี่ยนแปลงค่ามันได้ด้วย string value ("true" or "false")
        ->เช่น disabled (เปลี่ยนแปลงค่าที่เป็น string value ไม่มีผล disabled = "false" เพราะมันต้องการ true or false ที่เป็น boolean)
-ใช้กับ attribute ได้หมด แต่นิยมใช้กับ attribute ที่เป็น boolean เนื่องจากข้อจำกัดที่กล่าวไปข้างต้น
note : syntax [] or bind-ชื่อของ attribute

Class Binding
-> binding class css ว่าจะใช้หรือไม่ใช้ (ดูตัวอย่างที่ binding.component.ts)
-> ngClass คือการ set object ให้ binding class โดยที่เราไม่ต้องไป set หลายครั้ง set เป็น object รอบเดียวจบ (set multiple class)
-> รับค่าเป็น boolean

Style Binding
-> binding style css property
-> รับค่าเป็น string value ("''") or ('""')
-> สามารถใช้ condition expression ได้
-> ngStyle คือการ set object ให้ binding style (set multiple style)
    -> เราใช้ - ไม่ได้ (font-style ต้องเป็น camel case => fontStyle) ใน ngStyle
Note : ชื่อ property ใน Object ถ้าไม่มี "" or '' จะต้องพิมพ์ติดกันเป็น camel case

Event Binding
-> การส่ง data จาก component template สู่ component class
    -> syntax => (event)
    -> ทำผ่าน event handle (function ของ component class)
-> สามารถส่ง parameter event handle ได้ ($event)
    -> special var ของ angular (จะส่ง all information about DOM ของ event ที่เราทำ เช่น click)
        -> สามารถ access all property ของ DOM event
-> สามารถใช้ template statement แทน event handle ได้ (set property ผ่าน event binding ได้เลย)

Template Reference Variables
-> การ binding data ของ component template (refer html element และ all DOM property)
    -> syntax => #ตามด้วยชื่อตัวแปร
note : argument vs parameter
        -> sum(a,b) => retunr a+b; => a,b คือ parameter
        -> var result = sum(4,5); => 4,5 คือ argument

Two Way Binding
-> การเปลี่ยนแปลง data ที่ template ,data(property) ที่ class จะเปลี่ยนแปลงด้วย หรือ 
    เปลี่ยนแปลง data(property) ที่ class ,data ที่ template จะเปลี่ยนแปลงด้วย
-> syntax => [(ngModel)] -> ต้องเรียกใช้ FormsModule
    => [] property binding = data from class to template
    => () event binding = data from template to class

Ng-Directive (ดูตัวอย่างที่ ng-directive.component)
->NgIf (if เงื่อนไข ซ่อน แสดง Html element) => syntax *ngIf
    ->If else สามารถใช้ ng-template(template reference var) เข้ามาช่วย 
        -> เป็น container สำหรับ element อื่นที่มาใช้ร่วมกับ ng-if directive
-NgSwitch (switch statement สำหรับ multiple value) => syntax [ngSwitch] กับ *ngSwitchCase
-NgFor => syntax  *ngFor="let i of list" note: list คือ array ที่เราจะเอามา for-loop
    -> สามารถอ้างอิง Index ของ array ได้ ด้วย index as i (i หรือ ชื่ออะไรก็ได้)
    -> สามารถ check ว่าเป็น first element ได้ด้วย first as f (f หรือ ชื่ออะไรก็ได้)
    -> สามารถ check ว่าเป็น last element ได้ด้วย last as l (l หรือ ชื่ออะไรก็ได้)
    -> สามารถ check ว่า index เป็น odd ได้ด้วย odd as o (o หรือ ชื่ออะไรก็ได้)
    -> สามารถ check ว่า index เป็น even ได้ด้วย even as e (e หรือ ชื่ออะไรก็ได้)

Component Interaction (ดูตัวอย่างที่ component-interaction.component)
-> คือการรับ-ส่ง data ระหว่าง Parent component กับ Child component
-> component ที่เป็น parent component
    -> สามารถมี child component ซึ่งทำงานอิสระต่อกัน
-> วิธีรับ-ส่ง data จะใช้
    -> ส่ง data จาก parent ไปที่ child
        -> declare property ที่จะส่ง แล้วกำหนด property binding ให้กับ selector ของ component ที่ต้องการให้เป็น child 
        เช่น [parentData]="propertyที่จะส่ง"
        -> ใช้ decorator input (@input) ที่ child ให้กับ property ที่เราจะเอาไว้รับค่าที่ส่งมาจาก parent 
        (child component จะรับ data(input) จาก parent component) แล้วนำ property ที่รับค่ามานั้น ไป binding ใน child component template ต่อ

    -> รับ data จาก child (่ส่ง data จาก child ไป parent)
        -> สร้าง event ในการส่ง data จาก child ไป parent (EventEmiiter) ที่ child
        -> ใช้ decorator output (@output) ที่ child ให้กับ event ที่เราสร้าง
        (child component จะส่ง data (output) ไปที่ parent component)
        -> สร้าง event binding (childEvent) ที่ parent component ให้กับ selector ของ component ที่เป็น child + สร้าง property ที่รับค่าจาก event ที่ได้จาก child
note: 
    ->จากตัวอย่าง app.component เป็น parent ส่วน component-interaction.component เป็น child
    ->@input , @output สามารถ define ชื่อให้มันได้
    ->decorator ของ component มีได้แค่ decorator เดียว?

Pipes (ดูตัวอย่างที่ pipes.component.html)
-> ใช้แปลง data ก่อนจะเอาไปแสดงที่ view จะไม่เปลี่ยแปลงค่าของ property ของ class

Dependency Injection
-> dependency คือการที่ constructor ของ class รับ parameter เข้ามา
Ex.
class Engine {
    constructor(newParemeter) {

    }
}

class Tires {
    constructor(newParemeter) {

    }
}

class Car {
    engine; -> มี dependency 2 ตัว คือ engine,tires
    tires;
    constructor() {
        this.engine = new Engine();
        this.tires = new Tires();
    }
}
Note: code drawbacks ไม่ flexible เพราะถ้า dependency ที่เราไป instance มามีการรับ parameter จะทำให้ Car เราพังเนื่องจาก Engine 
ที่เรา instance มามันมีการรับ parameter เพราะฉะนั้นตอน instance มาใช้ใน Car ต้องรับ argument เข้ามาด้วย 
การเปลี่ยน dependency ของ class ที่ instance มาใช้ ทำให้เราต้องเปลี่ยนตามด้วยใน class ที่นำมาใช้

-> dependency injection คือการที่ class รับ dependency จากภายนอกแทนการ instance มาใช้ (ใน constructor) 
จะเห็นว่า code flexible มากตามตัวอย่างข้างล่าง
Ex.
class Car {
    engine; 
    tires;
    
    constructor(engine,tires) { -> รับ dependency จากภายนอกแทน
        this.engine = engine;
        this.tires = tires;
    }
}

var myEngine = new Engine();               |     var myEngine = new Engine(parameter);     |      var myEngine = new Engine(parameter);
var myTires = new Tires();                 |     var myTires = new Tires();                |      var myTires = new Tires(parameter);
var myCar = new Car(myEngine,myTires);     |     var myCar = new Car(myEngine,myTires);    |      var myCar = new Car(myEngine,myTires);

Ex. ถ้าเกิดเรามี dependency เยอะ เราต้องสร้าง inpendency ทั้งหมดที่เราจะใช้ก่อนจะเอาไปสร้าง Car 
ซึ่งเป็นเรื่องยากที่จะจัดการหาก dependency มีเยอะมากๆ
var myEngine = new Engine();
var myTires = new Tires();
var depA = new dependency();
var depB = new dependency();
var depC = new dependency();
var myCar = new Car(myEngine,myTires,depA,depB,depC);
Note: ใน angular เราใช้ dependency injection ในการทำ service ห้ามทำ draw back เพราะมันไม่ flexible และไม่ standard ที่เค้าทำกัน
    -> สร้าง service 
    -> register service ด้วย angular injector (ex. HttpClient)
    -> declare service ที่เป็น dependency ที่เราต้องการใช้ (พวก class ที่เราต้องการเอามาใช้ใน service)
- dependency injection ใน angular แค่ inject dependency เข้ามาก็สามารถใช้ dependency ของ class อื่นได้เลย ไม่ต้องสร้าง Instance 
เพียงแค่ declare ใน parameter ของ constructor ก็สามารถเอาไปใช้ได้เลย
  
Service (ดูตัวอย่างที่ employee.service.ts,for-service1.component,for-service2.component)
-> โดยหลักการแล้ว เราไม่ควรจัดการกับ data ใน class (class ควรจัดการแค่ logic ที่ควบคุม view) หรือถ้ามีการใช้ data ซ้ำๆหลายที่ 
    -> เราควรใช้ service จัดการ
-> เป็น class ที่จัดการเรื่องที่มัน specific
    -> ใช้ share data ให้หลายๆ component
    -> ใช้จัดการ Logic จัดการ data
    -> ใช้จัดการการเชื่อมต่อ database รับส่งข้อมูล 
note: 
    -ยึดตาม principle programmingS
        -> Do Not Repeat Yourself (DRY)
        -> Single Responsibility Principle
    -วิธีตั้งชื่อ service => xxxx.service.ts
-> step ในการทำ service
    -> สร้าง service
    -> จัดการ data (สร้าง function get data)
    -> register service (ด้วยการ injection)
        => ควร register ที่ app module(app module คือชั้นบนสุด) -> เพื่อที่จะสามารถนำไปใช้ได้ทุกที่ (register ที่ providers ที่เป็น angular injector)
    -> dependency injection service ใน class component ที่เราต้องการใช้
    note : ถ้า register service ที่ไหนแล้ว สามารถใช้ service กับตัวมันและ child มันได้
note : 
    ->Injectable decorator ใน service เป็นตัวบอกว่า class นี้เป็น service
        -> ทำให้สามารถใช้ dependency injection ได้ 
        -> ถ้าต้องการ inject service อื่นเข้ามาใช้ใน service เราจะต้องใช้ Injectable decorator 
    -> component class ไม่ได้มี Injectable decorator แต่ก็ยังสามารถใช้ service ได้ 
    เพราะมี component decorator ที่ทำให้สามารถใช้ dependency injection ได้ 
    แต่ service ไม่มี component decorator แล้วถ้าเอา Injectable decorator ออกจาก service มันจะกลายเป็น class ธรรมดา

Http and Observables
-> เราดึง data จาก server ผ่าน service ด้วย Http request
    -> ส่ง Http request ไปที่ web api หรือ web service เพื่อไปดึง data จาก database แล้วส่ง Http response กลับมา 
-> Observable คือ Http response ที่ได้กลับมา
-> step การทำงานของ Http
    -> service ส่ง Http request ไปที่ web api or web service เพื่อไปดึง data จาก database
    -> database ส่ง Observable (Http response) กลับมา แปลง Observable ที่ได้ให้เป็นโมเดล data ที่เราต้องการนำไปแสดง (cast observable ให้เป็นโมเดล data)
    -> subscribe ตัว Observable ไปใช้ต่อที่ component ที่เราต้องการใช้แสดงข้อมูล (subscribe เป็นตัวแปลง Observable ที่ถูก cast ให้เป็นก้อน data)
        -> แปลง Http response ให้กลายเป็นก้อน data
    -> สร้าง array data ที่ Local แล้วนำ subscribe data ที่ได้มาเก็บที่ตัวแปร local
Note : 
-> RxJs(Reactive Extensions for Javascript)
    -> เป็น library ที่จัดการเกี่ยวกับ Observable ใน angular (เป็น external library ที่ทำงานด้วย observable)

Fetch Data Using HTTP
- import HttpClientModule ใน imports ของ app.module (เพื่อ register Http service มาใช้ใน angular)
- dependency injection HttpClient ที่ service ที่เราจะใช้
- สร้าง model ของ data
- สร้าง url ที่จะใช้ยิง request 
- สร้าง Method ที่ส่ง Http request และรับ Http response กลับมา return observable
- dependency injection service ไปใช้ที่ component ที่ต้องการ
- subscribe ตัว Observable ที่ได้จาก Method ของ service -> จะได้ data มา
- เอา data ที่ได้มาเก็บที่ตัวแปร Local (property ของ component) เพื่อเอาไปใช้ binding ต่อ

HTTP Error Handling
- ใช้ catch ในการ handle exception error -> ใน argument จะรับ method ที่จัดการ error
- จะโชว์ message error ให้กับ component ที่ subscripe observable ไปใช้
- step
    -> import 'rxjs/add/operator/catch' เพื่อใช้ catch กับ import 'rxjs/add/observable/throw';